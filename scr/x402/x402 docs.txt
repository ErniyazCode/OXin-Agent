Welcome to x402
This guide will help you understand x402, the open payment standard, and help you get started building or integrating services with x402.

x402 is the open payment standard that enables services to charge for access to their APIs and content directly over HTTP. It is built around the HTTP 402 Payment Required status code and allows clients to programmatically pay for resources without accounts, sessions, or credential management.

With x402, any web service can require payment before serving a response, using crypto-native payments for speed, privacy, and efficiency.

Want to contribute to our docs? The GitBook repo is open to PRs!  Our only ask is that you keep these docs as a neutral resource, with no branded content other than linking out to other resources where appropriate. 

Note about the docs: These docs are the credibly neutral source of truth for x402, as x402 is a completely open standard under the Apache-2.0 license. Coinbase Developer Platform is currently sponsoring AI-powered docs for users here, as we migrate to our own AI-powered solution on the main x402.org domain.

Why Use x402?
x402 addresses key limitations of existing payment systems:

High fees and friction with traditional credit cards and fiat payment processors

Incompatibility with machine-to-machine payments, such as AI agents

Lack of support for micropayments, making it difficult to monetize usage-based services

Who is x402 for?
Sellers: Service providers who want to monetize their APIs or content. x402 enables direct, programmatic payments from clients with minimal setup.

Buyers: Human developers and AI agents seeking to access paid services without accounts or manual payment flows.

Both sellers and buyers interact directly through HTTP requests, with payment handled transparently through the protocol.

What Can You Build?
x402 enables a range of use cases, including:

API services paid per request

AI agents that autonomously pay for API access

Paywalls for digital content

Microservices and tooling monetized via microtransactions

Proxy services that aggregate and resell API capabilities

How Does It Work?
At a high level, the flow is simple:

A buyer requests a resource from a server.

If payment is required, the server responds with 402 Payment Required, including payment instructions.

The buyer prepares and submits a payment payload.

The server verifies and settles the payment using an x402 facilitator's /verify and /settle endpoints.

If payment is valid, the server provides the requested resource.

For more detail, see:

Client / Server

Facilitator

HTTP 402

Roadmap
x402 is designed as an open standard, and we're excited to build x402 alongside our community. Some items in the roadmap we're excited about include:


 Solutions guides and templates for proxy servers and tools to make an x402 integration as easy as possible


exact scheme support on Solana (SVM)


upto scheme EVM & SVM


easier semantics for arbitrary tokens using permit as an alt method to transferWithAuthorization (likely via permit and an up to scheme)


Arbitrary token support


Production-ready marketplace and reputation system for x402-compatible endpoints

The goal is to make programmatic commerce accessible, permissionless, and developer-friendly.


Quickstart for Sellers
This guide walks you through integrating with x402 to enable payments for your API or service. By the end, your API will be able to charge buyers and AI agents for access.

Prerequisites
Before you begin, ensure you have:

A crypto wallet to receive funds (any EVM-compatible wallet)

Node.js and npm (or Python and pip) installed

An existing API or server

Note
We have pre-configured examples available in our repo for both Node.js and Python. We also have an advanced example that shows how to use the x402 SDKs to build a more complex payment flow.

1. Install Dependencies
Node.js
Express
Next.js
Hono
MCP (Unofficial)
Install the x402 Express middleware package.


Copy
npm install x402-express
npm install @coinbase/x402 # for the mainnet facilitator
Python
FastAPI/Flask
Install the x402 Python package


Copy
pip install x402
pip install cdp # for the mainnet facilitator
2. Add Payment Middleware
Integrate the payment middleware into your application. You will need to provide:

The Facilitator URL or facilitator object. For testing, use https://x402.org/facilitator which works on Base Sepolia and Solana devnet.

For more information on running in production on mainnet, check out CDP's Quickstart for Sellers

The routes you want to protect.

Your receiving wallet address.

Express
Next.js
Hono
MCP (Unofficial)
FastAPI
Flask
Full example in the repo here.


Copy
import express from "express";
import { paymentMiddleware, Network } from "x402-express";

const app = express();

app.use(paymentMiddleware(
  "0xYourAddress", // your receiving wallet address
  {  // Route configurations for protected endpoints
      "GET /weather": {
        // USDC amount in dollars
        price: "$0.001",
        network: "base-sepolia",
      },
    },
  {
    url: "https://x402.org/facilitator", // Facilitator URL for Base Sepolia testnet.
  }
));

// Implement your route
app.get("/weather", (req, res) => {
  res.send({
    report: {
      weather: "sunny",
      temperature: 70,
    },
  });
});

app.listen(4021, () => {
  console.log(`Server listening at http://localhost:4021`);
});
This is the interface for the payment middleware config:


Copy
interface PaymentMiddlewareConfig {
  description?: string;               // Description of the payment
  mimeType?: string;                  // MIME type of the resource
  maxTimeoutSeconds?: number;         // Maximum time for payment (default: 60)
  outputSchema?: Record; // JSON schema for the response
  customPaywallHtml?: string;         // Custom HTML for the paywall
  resource?: string;                  // Resource URL (defaults to request URL)
}
When a request is made to this route without payment, your server will respond with the HTTP 402 Payment Required code and payment instructions.

3. Test Your Integration
To verify:

Make a request to your endpoint (e.g., curl http://localhost:3000/your-endpoint).

The server responds with a 402 Payment Required, including payment instructions in the body.

Complete the payment using a compatible client, wallet, or automated agent. This typically involves signing a payment payload, which is handled by the client SDK detailed in the Quickstart for Buyers.

Retry the request, this time including the X-PAYMENT header containing the cryptographic proof of payment (payment payload).

The server verifies the payment via the facilitator and, if valid, returns your actual API response (e.g., { "data": "Your paid API response." }).

4. Error Handling
If you get an error stating Cannot find module 'x402-hono/express' or its corresponding type declarations., add the tsconfig.json from the Hono example to your project.

npm install the dependencies in each example

Next Steps
Looking for something more advanced? Check out the Advanced Example

Get started as a buyer

For questions or support, join our Discord.

Summary
This quickstart covered:

Installing the x402 SDK and relevant middleware

Adding payment middleware to your API and configuring it

Testing your integration

Your API is now ready to accept crypto payments through x402.


Quickstart for Buyers
This guide walks you through how to use x402 to interact with services that require payment. By the end of this guide, you will be able to programmatically discover payment requirements, complete a payment, and access a paid resource.

Prerequisites
Before you begin, ensure you have:

A crypto wallet with USDC (any EVM-compatible wallet)

Node.js and npm, or Python and pip

A service that requires payment via x402

Note
We have pre-configured examples available in our repo, including examples for fetch, Axios, and MCP.

1. Install Dependencies
Node.js
Python
HTTP Clients (Axios/Fetch) Install x402-axios or x402-fetch:


Copy
npm install x402-axios
# or
npm install x402-fetch
MCP (Unofficial) This community package showcases how AI agents can use Model Context Protocol (MCP) with x402. We're working on enshrining an official MCP spec in x402 soon.

Install the required packages for MCP support:


Copy
npm install x402-mcp ai @modelcontextprotocol/sdk
2. Create a Wallet Client
Create a Wallet Client
Node.js (viem)
Python (eth-account)
Install the required package:


Copy
npm install viem
Then instantiate the wallet account:


Copy
import { createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { baseSepolia } from "viem/chains";

// Create a wallet client (using your private key)
const account = privateKeyToAccount("0xYourPrivateKey"); // we recommend using an environment variable for this
Solana (SVM)
Use SolanaKit to instantiate a signer:


Copy
import { createKeyPairSignerFromBytes } from "@solana/kit";
import { base58 } from "@scure/base";

// 64-byte base58 secret key (private + public)
const signer = await createKeyPairSignerFromBytes(
  base58.decode(process.env.SOLANA_PRIVATE_KEY!)
);
3. Make Paid Requests Automatically
Node.js
You can use either x402-fetch or x402-axios to automatically handle 402 Payment Required responses and complete payment flows.

Fetch
Axios
x402-mcp
x402-fetch extends the native fetch API to handle 402 responses and payment headers for you. Full example here


Copy
import { wrapFetchWithPayment, decodeXPaymentResponse } from "x402-fetch";
// other imports...

// wallet creation logic...

const fetchWithPayment = wrapFetchWithPayment(fetch, account);

fetchWithPayment(url, { //url should be something like https://api.example.com/paid-endpoint
  method: "GET",
})
  .then(async response => {
    const body = await response.json();
    console.log(body);

    const paymentResponse = decodeXPaymentResponse(response.headers.get("x-payment-response")!);
    console.log(paymentResponse);
  })
  .catch(error => {
    console.error(error.response?.data?.error);
  });
Python
You can use either httpx or Requests to automatically handle 402 Payment Required responses and complete payment flows.

Requests is a well-established library for synchronous HTTP requests. It is simple and ideal for straightforward, sequential workflows.

HTTPX is a modern library that supports both synchronous and asynchronous (async) HTTP requests. Use HTTPX if you need high concurrency, advanced features like HTTP/2, or want to leverage Python’s async capabilities

Both support a simple and extensible approach. The simple returns a pre-configured client that handles payments automatically, while the extensible lets you use an existing session/client. The simple is covered here, while the extensible is in the README of the full examples linked below.

HTTPX
Requests
Full example here


Copy
from x402.clients.httpx import x402HttpxClient
# Other imports...

# Wallet creation logic ...

# Create client and make request
async with x402HttpxClient(account=account, base_url="https://api.example.com") as client:
    response = await client.get("/protected-endpoint")
    print(await response.aread())
4. Error Handling
Clients will throw errors if:

The request configuration is missing

A payment has already been attempted for the request

There is an error creating the payment header

Summary
Install an x402 client package

Create a wallet client

Use the provided wrapper/interceptor to make paid API requests

Payment flows are handled automatically for you

References:

x402-fetch npm docs

x402-axios npm docs

x402 PyPi page

HTTP 402
For decades, HTTP 402 Payment Required has been reserved for future use. x402 unlocks it, and absolves the internet of its original sin.

What is HTTP 402?
HTTP 402 is a standard, but rarely used, HTTP response status code indicating that payment is required to access a resource.

In x402, this status code is activated to:

Inform clients (buyers or agents) that payment is required.

Communicate the details of the payment, such as amount, currency, and destination address.

Provide the information necessary to complete the payment programmatically.

Why x402 Uses HTTP 402
The primary purpose of HTTP 402 is to enable frictionless, API-native payments for accessing web resources, especially for:

Machine-to-machine (M2M) payments (e.g., AI agents).

Pay-per-use models such as API calls or paywalled content.

Micropayments without account creation or traditional payment rails.

Using the 402 status code keeps x402 protocol natively web-compatible and easy to integrate into any HTTP-based service.

Summary
HTTP 402 is the foundation of the x402 protocol, enabling services to declare payment requirements directly within HTTP responses. It:

Signals payment is required

Communicates necessary payment details

Integrates seamlessly with standard HTTP workflows

Client / Server
This page explains the roles and responsibilities of the client and server in the x402 protocol.

Understanding these roles is essential to designing, building, or integrating services that use x402 for programmatic payments.

Note
Client refers to the technical component making an HTTP request. In practice, this is often the buyer of the resource.

Server refers to the technical component responding to the request. In practice, this is typically the seller of the resource

Client Role
The client is the entity that initiates a request to access a paid resource.

Clients can include:

Human-operated applications

Autonomous agents

Programmatic services acting on behalf of users or systems

Responsibilities
Initiate requests: Send an HTTP request to the resource server.

Handle payment requirements: Read the 402 Payment Required response and extract payment details.

Prepare payment payload: Use the provided payment requirements to construct a valid payment payload.

Resubmit request with payment: Retry the request with the X-PAYMENT header containing the signed payment payload.

Clients do not need to manage accounts, credentials, or session tokens beyond their crypto wallet. All interactions are stateless and occur over standard HTTP requests.

Server Role
The server is the resource provider enforcing payment for access to its services.

Servers can include:

API services

Content providers

Any HTTP-accessible resource requiring monetization

Responsibilities
Define payment requirements: Respond to unauthenticated requests with an HTTP 402 Payment Required, including all necessary payment details in the response body.

Verify payment payloads: Validate incoming payment payloads, either locally or by using a facilitator service.

Settle transactions: Upon successful verification, submit the payment for settlement.

Provide the resource: Once payment is confirmed, return the requested resource to the client.

Servers do not need to manage client identities or maintain session state. Verification and settlement are handled per request.

Communication Flow
The typical flow between a client and a server in the x402 protocol is as follows:

Client initiates request to the server for a paid resource.

Server responds with 402 Payment Required, including the payment requirements in the response body.

Client prepares and submits a payment payload based on the provided requirements.

Server verifies the payment payload, either locally or through a facilitator service.

Server settles the payment and confirms transaction completion.

Server responds with the requested resource, assuming payment was successful.

Summary
In the x402 protocol:

The client requests resources and supplies the signed payment payload.

The server enforces payment requirements, verifies transactions, and provides the resource upon successful payment.

This interaction is stateless, HTTP-native, and compatible with both human applications and automated agents.

Next, explore:

Facilitator — how servers verify and settle payments

HTTP 402 — how servers communicate payment requirements to clients


Facilitator
This page explains the role of the facilitator in the x402 protocol.

The facilitator is an optional but recommended service that simplifies the process of verifying and settling payments between clients (buyers) and servers (sellers).

What is a Facilitator?
The facilitator is a service that:

Verifies payment payloads submitted by clients.

Settles payments on the blockchain on behalf of servers.

By using a facilitator, servers do not need to maintain direct blockchain connectivity or implement payment verification logic themselves. This reduces operational complexity and ensures accurate, real-time validation of transactions.

Facilitator Responsibilities
Verify payments: Confirm that the client's payment payload meets the server's declared payment requirements.

Settle payments: Submit validated payments to the blockchain and monitor for confirmation.

Provide responses: Return verification and settlement results to the server, allowing the server to decide whether to fulfill the client's request.

The facilitator does not hold funds or act as a custodian - it performs verification and execution of onchain transactions based on signed payloads provided by clients.

Why Use a Facilitator?
Using a facilitator provides:

Reduced operational complexity: Servers do not need to interact directly with blockchain nodes.

Protocol consistency: Standardized verification and settlement flows across services.

Faster integration: Services can start accepting payments with minimal blockchain-specific development.

While it is possible to implement verification and settlement locally, using a facilitator accelerates adoption and ensures correct protocol behavior.

Live Facilitators
Currently, CDP hosts a facilitator live on Base mainnet. For more information about getting started, see the CDP Docs.

CDP's facilitator offers fee-free USDC settlement on Base mainnet

PayAI hosts a facilitator on Solana, Base, Polygon, and more. More info & docs at https://docs.payai.network/x402.

Interaction Flow
Client makes an HTTP request to a resource server

Resource server responds with a 402 Payment Required status and a Payment Required Response JSON object in the response body.

Client selects one of the paymentDetails returned by the accepts field of the server response and creates a Payment Payload based on the scheme of the paymentDetails they have selected.

Client sends the HTTP request with the X-PAYMENT header containing the Payment Payload to the resource server

Resource server verifies the Payment Payload is valid either via local verification or by POSTing the Payment Payload and Payment Details to the /verify endpoint of the facilitator server.

Facilitator server performs verification of the object based on the scheme and networkId of the Payment Payload and returns a Verification Response

If the Verification Response is valid, the resource server performs the work to fulfill the request. If the Verification Response is invalid, the resource server returns a 402 Payment Required status and a Payment Required Response JSON object in the response body.

Resource server either settles the payment by interacting with a blockchain directly, or by POSTing the Payment Payload and Payment Details to the /settle endpoint of the facilitator server.

Facilitator server submits the payment to the blockchain based on the scheme and networkId of the Payment Payload.

Facilitator server waits for the payment to be confirmed on the blockchain.

Facilitator server returns a Payment Execution Response to the resource server.

Resource server returns a 200 OK response to the Client with the resource they requested as the body of the HTTP response, and a X-PAYMENT-RESPONSE header containing the Settlement Response as Base64 encoded JSON if the payment was executed successfully.

Summary
The facilitator acts as an independent verification and settlement layer within the x402 protocol. It helps servers confirm payments and submit transactions onchain without requiring direct blockchain infrastructure.

Next, explore:

Client / Server — understand the roles and responsibilities of clients and servers

HTTP 402 — understand how payment requirements are communicated to clients

Wallet
This page explains the role of the wallet in the x402 protocol.

In x402, a wallet is both a payment mechanism and a form of unique identity for buyers and sellers. Wallet addresses are used to send, receive, and verify payments, while also serving as identifiers within the protocol.

Role of the Wallet
For Buyers
Buyers use wallets to:

Store USDC/crypto

Sign payment payloads

Authorize onchain payments programmatically

Wallets enable buyers, including AI agents, to transact without account creation or credential management.

For Sellers
Sellers use wallets to:

Receive USDC/crypto payments

Define their payment destination within server configurations

A seller's wallet address is included in the payment requirements provided to buyers.

CDP's Wallet API is our recommended option for programmatic payments and secure key management.

Summary
Wallets enable programmatic, permissionless payments in x402.

Buyers use wallets to pay for services.

Sellers use wallets to receive payments.

Wallet addresses also act as unique identifiers within the protocol.

Bazaar (Discovery Layer)
The x402 Bazaar is the discovery layer for the x402 ecosystem - a machine-readable catalog that helps developers and AI agents find and integrate with x402-compatible API endpoints. Think of it as a search index for payable APIs, enabling the autonomous discovery and consumption of services.

The x402 Bazaar is in early development. While our vision is to build the "Google for agentic endpoints," we're currently more like "Yahoo search" - functional but evolving. Features and APIs may change as we gather feedback and expand capabilities.

Overview
The Bazaar solves a critical problem in the x402 ecosystem: discoverability. Without it, x402-compatible endpoints are like hidden stalls in a vast market. The Bazaar provides:

For Buyers (API Consumers): Programmatically discover available x402-enabled services, understand their capabilities, pricing, and schemas

For Sellers (API Providers): Automatic visibility for your x402-enabled services to a global audience of developers and AI agents

For AI Agents: Dynamic service discovery without pre-baked integrations - query, find, pay, and use

How It Works
The Bazaar currently provides a simple /list endpoint that returns all x402-compatible services registered with the CDP facilitator. Services are automatically opted-in when they use the CDP facilitator, making discovery frictionless for sellers.

Note: While a discovery layer is live today for the CDP Facilitator, the spec for the marketplace items is open and part of the x402 scheme, meaning any facilitator can create their own discovery layer. 

Basic Flow
Discovery: Clients query the /list endpoint to find available services

Selection: Choose a service based on price, capabilities, and requirements

Execution: Use x402 to pay for and access the selected service

No Manual Setup: No API keys, no account creation, just discover and pay

API Reference
List Endpoint
Retrieve all available x402-compatible endpoints:


Copy
GET https://api.cdp.coinbase.com/platform/v2/x402/discovery/resources
Note: the recommended way to use this endpoint is to use the useFacilitator hook as described below.

Response Schema

Each endpoint in the list contains the following fields:


Copy
{
      "accepts": [
        {
          "asset": "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913", // ERC-20 token contract address accepted for payment (here, USDC on Base)
          "description": "", // Optional description of the accepted payment
          "extra": {
            "name": "USD Coin", // Human-readable name of the asset
            "version": "2" // Version of the asset, if applicable
          },
          "maxAmountRequired": "200", // Maximum amount (in atomic units, e.g USDC has 6 decimals) required for the service
          "maxTimeoutSeconds": 60, // Maximum time (in seconds) the service will wait for payment before expiring
          "mimeType": "", // Expected MIME type for the response (optional/empty if not specified)
          "network": "base", // network where payment is accepted (e.g., 'base' for Base L2)
          "outputSchema": {
            "input": {
              "method": "GET", // HTTP method to use when calling the resource
              "type": "http" // Type of resource (e.g., 'http' endpoint)
            },
            "output": null // Output schema (null if not specified)
          },
          "payTo": "0xa2477E16dCB42E2AD80f03FE97D7F1a1646cd1c0", // Address to which payment should be sent
          "resource": "https://api.example.com/x402/last_sold", // The actual API endpoint/resource URL
          "scheme": "exact" // Payment scheme (e.g., 'exact' means exact amount required)
        }
      ],
      "lastUpdated": "2025-08-09T01:07:04.005Z", 
      "metadata": {}, // Additional metadata about the service (empty object if none)
      "resource": "https://api.prixe.io/x402/last_sold", // The main resource URL for this service
      "type": "http", 
      "x402Version": 1 // Version of the x402 protocol supported
    },
Quickstart for Buyers
See the full example here for Python and Node.js.

Step 1: Discover Available Services
Fetch the list of available x402 services using the facilitator client:

Typescript:


Copy
import { useFacilitator } from "x402/verify";
import { facilitator } from "@coinbase/x402";


const { list } = useFacilitator(facilitator);

// Fetch all available services
const services = await list();

// NOTE: in an MCP context, you can see the full list then decide which service to use

// Find services under $0.10
const usdcAsset = "0x036CbD53842c5426634e7929541eC2318f3dCF7e";
const maxPrice = 100000;

const affordableServices = services.items.filter(item => item.accepts.find(paymentRequirements => paymentRequirements.asset == usdcAsset && Number(paymentRequirements.maxAmountRequired) < maxPrice));
Python:


Copy
from x402.facilitator import FacilitatorClient, FacilitatorConfig
from cdp.x402 import create_facilitator_config

# Set up facilitator client
facilitator_config = create_facilitator_config()
facilitator = FacilitatorClient(facilitator_config)

# Fetch all available services
services = await facilitator.list()

# NOTE: in an MCP context, you can see the full list then decide which service to use

# Find services under $0.10
usdc_asset = "0x036CbD53842c5426634e7929541eC2318f3dCF7e"
max_price = 100000

affordable_services = [
  item
  for item in services.items
  if any(
    payment_req.asset == usdc_asset
    and int(payment_req.max_amount_required) < max_price
    for payment_req in item.accepts
   )
  ]
Step 2: Call a Discovered Service
Once you've found a suitable service, use an x402 client to call it:

Typescript:


Copy
import { withPaymentInterceptor } from 'x402-axios'; 
import axios from 'axios'; 
import { privateKeyToAccount } from 'viem/accounts';

// Set up your payment account
const account = privateKeyToAccount('0xYourPrivateKey');

// Select a service from discovery
const selectedService = affordableServices[0];

// Create a payment-enabled client for that service
const client = withPaymentInterceptor(
  axios.create({ baseURL: selectedService.endpoint }), 
  account
);

// Select the payment method of your choice
const selectedPaymentRequirements = selectedService.accepts[0];
const inputSchema = selectedPaymentRequirements.outputSchema.input;

// Build the request using the service's schema
const response = await client.request({
  method: inputSchema.method,
  url: inputSchema.resource,
  params: { location: 'San Francisco' } // Based on inputSchema
});

console.log('Response data:', response.data);
Python: 


Copy
from x402.client import X402Client
from eth_account import Account

# Set up your payment account
account = Account.from_key('0xYourPrivateKey')
client = X402Client(account)

# Select a service from discovery
selected_service = affordable_services[0]

# Select the payment method of your choice
selected_payment_requirements = selected_service.accepts[0]
input_schema = selected_payment_requirements.output_schema.input

# Make the request
response = client.request({
    method=input_schema.method,
    url=input_schema.resource,
    params={ "location": "San Francisco" } # Based on input_schema
})

print(f"Response data: {response}")
Quickstart for Sellers
Automatic Listing with Discoverable Flag
If your API uses the latest version of the CDP facilitator for x402 payments, it's ingested in the bazaar if you make the discoverable flag true in the input schema (see below).

Adding Metadata
To enhance your listing with descriptions and schemas, include them when setting up your x402 middleware. You should include descriptions for each parameter to make it clear for the agent to call your endpoints:

Typescript: 


Copy
// Next.js / Express / Hono
 
import { require402Payment } from 'x402-express';

app.use(require402Payment({
  routes: {
    "/api/weather": {
      price: "$0.001",
      network: "base",
      config: {
        discoverable: true, // make your endpoint discoverable
        description: "Get current weather data for any location",
        inputSchema: { 
          queryParams: { 
            location: { 
              type: string, 
              description: "City name or coordinates", 
              required: true
            }
          }
        },
        outputSchema: {
          type: "object",
          properties: { 
            temperature: { type: "number" },
            conditions: { type: "string" },
            humidity: { type: "number" }
          }
        }
      }
    }
  }
}));
Python  


Copy
# FastAPI / Flask

from x402 import require_payment

app.middleware("http")(
    require_payment(
        path="/weather",
        price="$0.001",
        pay_to_address=WALLET_ADDRESS,
        network="base",
        description="Get current weather data for any location",
        discoverable=true, # make your endpoint discoverable <----
        input_schema={
            "queryParams": {
                "location": {
                    "type": string,
                    "description": "City name or coordinates",
                    "required": true
                }
            }
        },
        output_schema={
            "type": "object",
            "properties": {
                "temperature": {"type": "number"},
                "conditions": {"type": "string"},
                "humidity": {"type": "number"}
            }
        }
    )
)
```
Coming Soon
The x402 Bazaar is rapidly evolving, and your feedback helps us prioritize features.

Support
GitHub: github.com/coinbase/x402

Discord: Join #x402 channel

Documentation: x402 Overview

FAQ
Q: How do I get my service listed? A: If you're using the CDP facilitator, your service is listed once you include the discoverable flag

Q: How can I make endpoint calls more accurate? Include descriptions clearly stating what each parameter does and how to call your endpoint, but do so as succinctly as possible.

Q: How does pricing work? A: Listing is free. Services set their own prices per API call, paid via x402.

Q: What networks are supported? A: Currently Base (mainnet) with USDC payments.

Q: Can I list non-x402 services? A: No, only x402-compatible endpoints can be listed. See our seller quickstart to make your API x402-compatible.

Network & Token Support
This page explains which blockchain networks and tokens are supported by x402, and how to extend support to additional networks.

Overview
x402 is designed to work across multiple blockchain networks, with different levels of support depending on the facilitator being used. The protocol itself is network-agnostic, but facilitators need to implement network-specific logic for payment verification and settlement.

Supported Facilitators
Network support in x402 depends on which facilitator you use. Here are the currently available facilitators:

x402.org Facilitator
Supports: Base Sepolia, Solana Devnet

Notes: Recommended for testing and development. This is the default facilitator in the x402 packages and requires no setup.

URL: https://x402.org/facilitator

CDP's x402 Facilitator
Supports: Base, Base Sepolia, Solana, Solana Devnet

Notes: Production-ready for mainnet payments with KYT/OFAC compliance checks. Can also be used for testing on Base Sepolia. Requires CDP API keys. Uses facilitator object instead of facilitator URL.

Requirements: CDP account and API keys from cdp.coinbase.com, see Quickstart for Sellers: Running on Mainnet for more details.

x402.rs Facilitator
Supports: Base Sepolia, Base, XDC Mainnet

Notes: Rust-based facilitator operated by the x402 community.

URL: https://facilitator.x402.rs

PayAI Facilitator
Supports: Solana, Base, Polygon, Avalanche, Sei, Peaq, Iotex and all of their testnets.

Notes: Production-ready for mainnet payments. Supports all tokens on Solana, supports EIP-3009 tokens on EVM-Based chains.

URL: https://facilitator.payai.network

Self-Hosted Facilitators
Supports: Any EVM network

Notes: Run your own facilitator for full control and customization. Supports networks like Avalanche, Polygon, Arbitrum, and other EVM-compatible chains.

Setup: See "Adding Support for New Networks" section below

Third-Party Facilitators
Additional facilitators may be available from external providers. Check the x402 Discord community for the latest facilitator offerings.

Token Support
x402 supports tokens on both EVM and Solana networks:

EVM: Any ERC-20 token that implements the EIP-3009 standard

Solana: Any SPL or token-2022 token

Important: Facilitators support networks, not specific tokens — any EIP-3009 compatible token works on EVM networks, and any SPL/token-2022 token works on Solana, for the facilitators that support those networks.

EVM: EIP-3009 Requirement
Tokens must implement the transferWithAuthorization function from the EIP-3009 standard. This enables:

Gasless transfers: The facilitator sponsors gas fees

Signature-based authorization: Users sign transfer authorizations off-chain

Secure payments: Transfers are authorized by cryptographic signatures

Specifying Payment Amounts
When configuring payment requirements, you have two options:

Price String (e.g., "$0.01") - The system infers USDC as the token

TokenAmount - Specify exact atomic units of any EIP-3009 token

Using Custom EIP-3009 Tokens
To use a custom EIP-3009 token, you need three key pieces of information:

Token Address: The contract address of your EIP-3009 token

EIP-712 Name: The token's name for EIP-712 signatures

EIP-712 Version: The token's version for EIP-712 signatures

Finding Token Information on Basescan

You can retrieve the required EIP-712 values from any block explorer:

Name: Read the name() function - Example on Basescan

Version: Read the version() function - Example on Basescan

These values are used in the eip712 nested object when configuring TokenAmount:


Copy
{
  eip712: {
    name: "USD Coin",    // From name() function
    version: "2"         // From version() function
  }
}
Solana: SPL Tokens & Token 2022 Tokens
On Solana, x402 supports all SPL tokens and Token 2022 tokens. When using facilitators that support Solana or Solana Devnet, payments can be made in any SPL/token-2022 token, including USDC (SPL). No EIP-712 configuration is required on Solana.

USDC - The Default Token
Status: Supported by default across all networks

Why: USDC implements EIP-3009 and is widely available

Networks: Available on Base, Base Sepolia, and all supported networks

Why EIP-3009?
The EIP-3009 standard is essential for x402 because it enables:

Gas abstraction: Buyers don't need native tokens (ETH, MATIC, etc.) for gas

One-step payments: No separate approval transactions required

Universal facilitator support: Any EIP-3009 token works with any facilitator

Quick Reference
Facilitator
Networks Supported
Production Ready
Requirements
x402.org

base-sepolia, solana-devnet

❌ Testnet only

None

CDP Facilitator

base, base-sepolia, solana, solana-devnet

✅

CDP API keys

x402.rs

base-sepolia, base, xdc

✅

None

PayAI Facilitator

solana, solana-devnet, base, base-sepolia, polygon, polygon-amoy, avalanche, avalanche-fuji, sei, sei-testnet, peaq, iotex

✅

None

Self-hosted

Any EVM network

✅

Technical setup

Note: On EVM networks, facilitators support any EIP-3009 compatible token; on Solana, facilitators support any SPL/Token-2022 token.

Adding Support for New Networks
There are two ways to add support for new EVM networks in x402:

Option 1: Contributing to x402 Packages
You can add official network support by submitting a PR to the x402 repository. This makes your network available to all x402 users.

Files to Modify

typescript/packages/x402/src/types/shared/evm/config.ts

Add your network's chain ID and USDC address:


Copy
// Example: Adding Avalanche networks
"43113": {  // Avalanche Fuji testnet chain ID
  usdcAddress: "0x5425890298aed601595a70AB815c96711a31Bc65",
  usdcName: "USD Coin",
},
"43114": {  // Avalanche mainnet chain ID
  usdcAddress: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
  usdcName: "USDC",
},
typescript/packages/x402/src/types/shared/network.ts

Add your network to the schema and mappings:


Copy
// Update the NetworkSchema enum
export const NetworkSchema = z.enum(["base-sepolia", "base", "avalanche-fuji", "avalanche"]);

// Add to SupportedEVMNetworks array
export const SupportedEVMNetworks: Network[] = [
  "base-sepolia",
  "base",
  "avalanche-fuji",
  "avalanche",
];

// Add to EvmNetworkToChainId mapping
["avalanche-fuji", 43113],
["avalanche", 43114],
typescript/packages/x402/src/types/shared/evm/wallet.ts - Update getChainFromNetwork function

Add your network to the getChainFromNetwork function to map your network string to the viem chain object:


Copy
import { avalanche, avalancheFuji } from "viem/chains";

// Add your network to the switch statement in getChainFromNetwork
case "avalanche":
  return avalanche;
case "avalanche-fuji":
  return avalancheFuji;
Key Requirements

Network key: Use a consistent network identifier (e.g., avalanche-fuji) across all files

Viem chain: Your network must be available in viem/chains or you'll need to define it manually

USDC address: Must be EIP-3009 compatible (has transferWithAuthorization function)

Chain ID: Use your network's official chain ID in the config

Consistency: Ensure the network name matches across NetworkSchema, SupportedEVMNetworks, EvmNetworkToChainId, and the getChainFromNetwork switch statement

Option 2: Running Your Own Facilitator
If you need immediate support or want to test before contributing, you can run your own facilitator.

Video Guide: Adding EVM Chains to x402

Prerequisites

Access to an RPC endpoint for your target network

A wallet with native tokens for gas sponsorship

The x402 facilitator code

Future Network Support
The x402 ecosystem is actively expanding network support. Planned additions include:

Additional L2 networks

Additional non-EVM chain support

Cross-chain payment capabilities

Getting Help
For help with network integration:

Join the x402 Discord community

Check the x402 GitHub repository

Summary
x402's network support is designed to be extensible while maintaining security and reliability. Whether you're using the default Base Sepolia setup for testing or running your own facilitator for custom networks, the protocol provides flexibility for various use cases.

Key takeaways:

Base and Base Sepolia have the best out-of-the-box support

Any EVM network can be supported with a custom facilitator

Any EIP-3009 token (with transferWithAuthorization) works on any facilitator

Use price strings for USDC or TokenAmount for custom tokens

Network choice affects gas costs and payment economics

Next, explore:

Quickstart for Sellers — Start accepting payments on supported networks

Core Concepts — Learn how x402 works under the hood

Facilitator — Understand the role of facilitators

MCP Server — Set up AI agents to use x402 payments